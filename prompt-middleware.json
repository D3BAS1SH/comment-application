{
  "title": "Protect routes (middleware/route-guard) — Requirements & implementation spec",
  "summary": "Define a robust middleware/route-guard to protect client routes (e.g. /home) so only authenticated users can access them. The app uses Next.js (App Router), Redux Toolkit + redux-persist for client state, Axios clients with token refresh logic, and a separate auth-service for issuing/verifying tokens. This prompt describes two viable approaches (server-side middleware and client-side route guard), trade-offs, and a detailed implementation spec (inputs/outputs, edge cases, tests) so a developer or an LLM can implement a secure, robust solution.",
  "environment": {
    "framework": "Next.js (App Router)",
    "language": "TypeScript",
    "state": "Redux Toolkit + redux-persist (user slice)",
    "http_clients": "Axios (axios.client.ts + axios.auth.ts), axios interceptors handle refresh",
    "auth_service": "Separate microservice (auth-service) issues/verifies tokens",
    "note": "Redux state lives client-side (persisted). Next.js middleware runs server/edge and cannot access client Redux state."
  },
  "current_auth_summary_from_codebase": {
    "slice": "user slice (name: 'user') stores id, accessToken, refreshToken, isVerified, loading, error",
    "persist": "redux-persist used to persist 'user' slice into localStorage",
    "store_provider": "Provider + PersistGate wraps app (client). PersistGate rehydrates store on client",
    "axios": {
      "request": "token injected in axios.client request interceptor using getAccessToken() from redux hooks",
      "response": "axios.auth handles 401/ACCESS_TOKEN_EXPIRED: calls refreshToken (via client) and dispatches tokenRefreshed or logout"
    },
    "implication": "Auth state is available only on client after redux-persist rehydration. Server middleware cannot rely on Redux state."
  },
  "goals": [
    "Build a middleware or checker that reliably blocks access to protected routes (e.g. /home) unless the user is authenticated.",
    "Support additional routes added later via a central allowlist/denylist or pattern (e.g. /app/*).",
    "Integrate with the existing auth-service and token-refresh flow where possible (avoid duplicating secrets).",
    "Protect both a) server-side entry (redirects unauthenticated requests early) and/or b) client-side navigation when server-side cannot be used."
  ],
  "constraints": [
    "Redux state is client-side and cannot be read from server/edge middleware.",
    "Auth tokens should not be persisted insecurely. Prefer httpOnly cookies for server-side checks when possible.",
    "Keep UX: avoid flashing protected content when client state rehydrates (handle rehydration/loading state).",
    "Keep compatibility with existing axios refresh flow and auth-service behaviors."
  ],
  "recommended_solutions": {
    "A_server_side_middleware (recommended for security)": {
      "summary": "Use Next.js Middleware (edge) to protect routes by verifying an access token stored in an httpOnly cookie or Authorization header. This blocks unauthenticated requests before rendering and works for direct navigation and deep links.",
      "requirements": [
        "Store short-lived access token in an httpOnly cookie (Set-Cookie from auth-service on login) OR attach bearer token to requests from the client when navigating.",
        "auth-service must expose a token verification endpoint (or use JWT verification locally if keys available).",
        "Middleware must only call lightweight verification (validate signature or call auth-service) and then allow or redirect to /login.",
        "Public routes list must be maintained (login, register, static assets)."
      ],
      "high_level_flow": [
        "Middleware runs for each request (paths pattern configured).",
        "If path is public, pass through.",
        "Read token from cookie 'access_token' (httpOnly) or Authorization header.",
        "If no token -> redirect to /login (with returnTo param).",
        "If token exists -> verify: either decode+verify JWT signature (fast) OR call auth-service /api/v1/auth/verify-token (fast endpoint).",
        "If verification succeeds -> continue to requested page. Optionally attach user metadata to request headers (for downstream edge/server usage).",
        "If verification fails -> remove cookie (set expired) and redirect to /login.",
        "Edge case: token expired -> middleware can try a silent refresh (only if you store refresh token httpOnly as well) by calling auth-service /refresh; on success set new access cookie and continue; on failure redirect to /login."
      ],
      "API_contracts_expected": {
        "verify endpoint": {
          "method": "GET",
          "path": "/api/v1/auth/verify-token",
          "input": {
            "cookie": "access_token (httpOnly) or Authorization header: Bearer <token>"
          },
          "success": {
            "status": 200,
            "body": { "valid": true, "userId": "uuid", "email": "..." }
          },
          "failure": {
            "status": [401, 404, 400],
            "body": {
              "message": "...",
              "errorCode": ["EXPIRED_TOKEN", "NOTFOUND", "INVALID_TOKEN"]
            }
          }
        }
      },
      "implementation_notes": [
        "Write /middleware.ts at project root with path matcher: ['/home', '/dashboard', '/app/:path*'] or use regex.",
        "Use NextResponse.redirect for unauthenticated requests.",
        "Prefer verifying JWT locally if you have public key; otherwise call auth-service. Be mindful of latency (cache verification results briefly if needed).",
        "Do not read Redux in middleware; instead depend on secure cookie or header tokens."
      ],
      "pros": [
        "Strong security: blocks before page render",
        "Works for direct navigations and crawlers"
      ],
      "cons": [
        "Requires accessible token in cookie or header",
        "Requires small changes to how tokens are stored (httpOnly cookie preferred)"
      ]
    },
    "B_client_side_route_guard (easier if you cannot change token storage)": {
      "summary": "Guard rendered client routes using a protected layout or HOC that reads Redux state. Suitable when tokens are stored only in Redux and changing storage is not possible immediately.",
      "requirements": [
        "Redux state must be rehydrated before guard makes decision (use PersistGate or explicit rehydrate flag).",
        "Use a ProtectedLayout component for App Router route (e.g. app/(protected)/layout.tsx) that reads user state and either renders children or redirects to /login.",
        "Handle loading state to avoid content flash: show a spinner until rehydration completes or a short timeout elapses.",
        "Keep a publicRoutes list for client-side routing too.",
        "Keep axios token injection and refresh logic in place for API calls."
      ],
      "high_level_flow": [
        "ProtectedLayout runs on client (use 'use client').",
        "ProtectedLayout uses a hook (useSelector or getAccessToken) to read auth state.",
        "If rehydration is not complete -> show loading/skeleton.",
        "If user is authenticated (accessToken exists and optionally isVerified) -> render children.",
        "Else redirect to /login (client push).",
        "Provide a 'RequireAuth' utility that other components can call to gate actions (e.g. clicking create-post prompts login)."
      ],
      "implementation_notes": [
        "Add a `rehydrated` flag (from PersistGate) or hook to detect when redux-persist finished rehydration.",
        "StoreProvider can expose a small API or context with `rehydrated` boolean so layouts can wait until it's safe to read auth state.",
        "Example: In app/home/layout.tsx wrap children with <ProtectedLayout> (client) which checks rehydration then user state.",
        "Use `router.replace('/login')` for redirect to avoid back-button confusion, and pass a returnTo query param.",
        "Edge-case: If rehydration shows stale/expired token, axios response interceptor will kick in and attempt refresh; the layout should show loading until interceptor resolves or times out."
      ],
      "pros": [
        "No server changes required",
        "Quick to implement within client codebase"
      ],
      "cons": [
        "Less secure for direct API endpoints (server can still serve HTML),",
        "depends on client state and rehydration — initial load needs careful UX"
      ]
    }
  },
  "detailed_spec_for_client_guard": {
    "component": "ProtectedLayout (client)",
    "props": ["children: React.ReactNode"],
    "behavior": {
      "onMount": "wait for rehydration flag or PersistGate to finish (max timeout e.g. 3s). If not rehydrated after timeout, attempt to read token from cookie (optional).",
      "authenticated": "if redux.user.accessToken exists (and optional user.isVerified true) -> render children.",
      "unauthenticated": "redirect to /login?returnTo=<currentPath>",
      "loading": "render <VerifyLoading /> or spinner while waiting for rehydration/refresh resolution."
    },
    "error_modes": [
      "expired token: axios interceptor will attempt refresh; during refresh show loading; if refresh fails -> clear store, redirect to /login",
      "no token: redirect to /login"
    ],
    "acceptance_criteria": [
      "Visiting /home while authenticated -> show content immediately (after any brief loading while rehydration completes).",
      "Visiting /home while not authenticated -> redirect to /login and do not briefly display protected content.",
      "If persisted tokens exist but are expired, page attempts transparent refresh; if refresh succeeds user sees content, else redirected."
    ]
  },
  "detailed_spec_for_edge_middleware": {
    "file": "/middleware.ts (root)",
    "match_paths": ["/home", "/dashboard", "/app/:path*"],
    "behavior": [
      "If request path matches public routes -> return NextResponse.next()",
      "Read cookie 'access_token' or Authorization header",
      "If missing -> redirect to /login?returnTo=<requestedPath>",
      "If present -> verify (fast): either locally verify JWT or call auth-service /api/v1/auth/verify-token",
      "If valid -> NextResponse.next(); if invalid/expired -> attempt refresh if refresh cookie present; else redirect to login."
    ],
    "security": [
      "Prefer httpOnly, SameSite=Strict cookies for access/refresh tokens",
      "Do not expose token values to client-side JS when using httpOnly",
      "Avoid long-lived tokens in localStorage (XSS risk)."
    ],
    "response_mappings": {
      "200": "allow",
      "401/404": "redirect to /login (optionally with message)",
      "5xx": "show error page or fallback to login with message"
    }
  },
  "edge_cases_and_tests": [
    {
      "case": "Client closed then reopened (rehydrate) with valid persisted tokens",
      "expected": "ProtectedLayout shows loading until rehydration, then shows content"
    },
    {
      "case": "Client persisted token expired",
      "expected": "ProtectedLayout waits, axios interceptor refreshes token; on success show content, on failure redirect to /login"
    },
    {
      "case": "Direct navigation to /home from new tab",
      "expected": "If using server middleware + cookie -> middleware verifies and allows/redirects; if client guard only -> initial HTML may be server-rendered but client will redirect after rehydration (less ideal)"
    },
    {
      "case": "Auth-service unresponsive",
      "expected": "middleware times out gracefully (short timeout), redirect to login with friendly message; client guard shows network error and gives retry option"
    }
  ],
  "implementation_steps_for_developer (suggested)": [
    "Decide server-side (middleware) vs client-side guard. For maximum security pick server-side middleware + httpOnly cookie storage.",
    "If server-side chosen: update auth login flow to set httpOnly cookies for access and refresh tokens; implement /middleware.ts that verifies tokens using auth-service or JWT verification.",
    "If client-only chosen: implement ProtectedLayout and ensure PersistGate or rehydration flag is used to prevent flashes. Add a maximum wait timeout and fall back to asking user to sign-in again.",
    "Update axios clients: if switching to httpOnly cookies, token injection from Redux is redundant for server requests; keep axios.auth refresh logic for client-side API calls, and prefer cookie-based refresh endpoints.",
    "Add unit/e2e tests for all edge cases (expired token, rehydrate, middleware redirects)."
  ],
  "deliverable": {
    "file_to_create": "prompt-middleware.json (this file)",
    "next_steps_for_LLM_or_dev": [
      "Implement chosen approach: create middleware.ts if server-side, or ProtectedLayout under app/(protected)/layout.tsx if client-side.",
      "Wire token storage: cookie vs localStorage (recommended: httpOnly cookie).",
      "Add tests and manual verification steps listed above."
    ]
  }
}
